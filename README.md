# AoC-2016

Advent of Code 2016
1. c-sharp
2. java
3. javascript
4. python
5. python
6. python
7. javascript
8. python
9. dart
10. dart
11. dart
12. ruby
13. ruby
14. java+python
15. R
16. c++
17. python
18. c++
19. c++
20. R
21. python
22. c++
23. ruby
24. python
25. ruby

## thoughts so far

### c-sharp - 1 try
Started AoC using c-sharp via Sharp-develop.

It might have been a mistake to use c-sharp for one of the first and thus easiest tasks. Though, it was good to learn the basic rules of AoC with a language I was familiar with.

It soon became clear that I was a bit too familiar. I do c-sharp in work, and even though I'm not certainly a top-class expert in it, I still got the "been there done that" -feeling.

The biggest learnings were more to do with the nature of AoC: if your program structure is poor, you will probably face difficulties. Doing good code will always help you to adjust to changes.

#### pros:
1. I'm familiar with c#
1. lot's of help
1. efficient
1. good tools
#### cons:
1. I'm a bit too familiar with c#

### java - 2 tries
For the second day, I switched to Java using NetBeans.

I have done some Java previously, and still, I don't know whether it's the tools I use or the language itself, but I'm not a friend of. To me, Java is maybe too much like c-sharp, but with some annoying little differences here and there.

After doing day 14 with Java, I like it even less.

#### pros:
1. I'm somewhat familiar with c#
1. similar to other c-like languages.
1. efficient

#### cons:
1. don't know exactly why, just don't like it

### javascript - 2 tries
I continued using NetBeans, this time for JavaScript.

Well, I can't say I liked JavaScript. It could be useful when you learn to use the async-methods, especially if you are doing web-programming. It took some time to get started, but in the end it's quite simple language.

#### pros:
1. lot's of help available

#### cons:
1. lot's of help is from web applications
1. still not as easy as python or ruby

### python - 8 tries
Time to move to Python. I installed Python via Anaconda, which helped quickly starting the work instead of spending time loading libraries. I wrote the code simply with Notepad++.

I liked Python. It probably isn't the fastest in some cases, but it's quite straightforward and despite being relatively new to me, it didn't bring any of those "oh god why" -moments that programming languages can sometimes bring.

Python required a lot of googling. Notepad++ doesn't offer by default much intellisense, but with Python that never hurt that much.

Learning the libraries and taking full advantages of advanced scripting would be essential in this language.

One thing though: I wrote day 14 first in Java, then recreated it with Python using practically the same structure, and ended up noticing that it run 2.5 times slower. Yet it was a lot quicker to work it otherwise.

#### pros:
1. somehow simple and straightforward

#### cons:
1. easily very slow
1. easily drags you into writing all the code in one function, which makes your code a bit ugly, which doesn't work that well when program size grows

### dart - 3 tries
A co-worker told me about Dart and how that will be next hipster-programming language. Had to try. I installed JetBrains, leaving with 30 days to learn Dart with that tool, before I probably need to switch to Atom instead.

A lot like Java and c-sharp. JetBrains was a good tool. Relatively easy language. There certainly is lot less instructions in Net available. And if you chose your search words poorly, you ended up into pages telling about tossing darts. Dart seems relatively new, meaning you need to rely more on official documentation rather than StackOverflow topics.

#### pros:
1. easy to adapt, very similar to other c-like languages

#### cons:
1. there are less help in web, or more difficult to find
1. need to setup a open source development kit some day

### ruby - 4 tries
Time to move to Ruby, using Atom as development environment and command line.

A new language to me. The day 12 was relatively simple, so this was a good moment to try.

Not a good first experience. Had some challenges with my variables, as Ruby allows you to mix variable types in a creative ways, but provided several occasions where simple comparisons didn't work because it was too easy to mix a string and an integer in an array.

#### pros:
1. relatively easy to adapt

#### cons:
1. easily makes you get confused with the variable types, since some errors only occur run-time
1. despite similarity, somehow not as nice as python

### R - 2 tries
I thought this was a mathmatical problem, and somehow I came up with R.

After few hours of investigations, I had figured out that day 15 was about systems of equations and especially Systems of Linear Congruences.

Yet the modulo part didn't come up anyway nicely, and the final solution was more like brute force that could be done with any language.

So didn't quite get into the heart of it yet :(.

#### pros:

#### cons:
1. less supported, sometimes difficult to find info
1. not the best if you don't know math enough to utilize all the libraries

### cpp - 4 tries
After initial confusion with the setup (I thought NetBeans would have already installed me the required compilers and all), I got to play with c++. More thoughts maybe later.

In the end, c++ didn't turn out so bad. The programs in this challenge were quite small, saving me from creating extra .hh files and binding them, which saved me a lot.

#### pros:
1. efficient
1. I'm familiar with c++
1. lot's of guidance available
1. with small program sizes, I didn't have to deal with .hh bindings

#### cons:
1. some relatively simple task like converting string to integer not very intuitive
